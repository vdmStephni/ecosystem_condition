<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>General workflow – Ecosystem Condition Assessments</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0583e13f578d10437cd59402472bc750.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Ecosystem Condition Assessments</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../content/overview/index.html"> 
<span class="menu-text">Overview</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../../content/workflow/index.html" aria-current="page"> 
<span class="menu-text">Workflow</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-thicket" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Thicket</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-thicket">    
        <li>
    <a class="dropdown-item" href="../../content/thicket/index.html">
 <span class="dropdown-text">Introduction</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../content/thicket/methods.html">
 <span class="dropdown-text">Methods</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../content/thicket/results.html">
 <span class="dropdown-text">Results</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-grassland" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Grassland</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-grassland">    
        <li>
    <a class="dropdown-item" href="../../content/grassland/index.html">
 <span class="dropdown-text">Introduction</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#goal-of-the-workflow" id="toc-goal-of-the-workflow" class="nav-link active" data-scroll-target="#goal-of-the-workflow">Goal of the workflow</a></li>
  <li><a href="#the-general-workflow" id="toc-the-general-workflow" class="nav-link" data-scroll-target="#the-general-workflow">The general workflow</a>
  <ul>
  <li><a href="#step-1-define-assessment-units-and-identify-relevant-experts" id="toc-step-1-define-assessment-units-and-identify-relevant-experts" class="nav-link" data-scroll-target="#step-1-define-assessment-units-and-identify-relevant-experts">Step 1 — Define assessment units and identify relevant experts</a></li>
  <li><a href="#step-2-identify-key-pressures-and-change-pathways" id="toc-step-2-identify-key-pressures-and-change-pathways" class="nav-link" data-scroll-target="#step-2-identify-key-pressures-and-change-pathways">Step 2 — Identify key pressures and change pathways</a></li>
  <li><a href="#step-3-define-a-reference-condition" id="toc-step-3-define-a-reference-condition" class="nav-link" data-scroll-target="#step-3-define-a-reference-condition">Step 3 — Define a reference condition</a></li>
  <li><a href="#step-4-select-ecosystem-specific-indicators-of-condition" id="toc-step-4-select-ecosystem-specific-indicators-of-condition" class="nav-link" data-scroll-target="#step-4-select-ecosystem-specific-indicators-of-condition">Step 4 — Select ecosystem-specific indicators of condition</a></li>
  <li><a href="#step-5-choose-remote-sensing-metrics-and-data-sources" id="toc-step-5-choose-remote-sensing-metrics-and-data-sources" class="nav-link" data-scroll-target="#step-5-choose-remote-sensing-metrics-and-data-sources">Step 5 — Choose remote-sensing metrics and data sources</a></li>
  <li><a href="#step-6-set-thresholds-if-discrete-classes-are-needed" id="toc-step-6-set-thresholds-if-discrete-classes-are-needed" class="nav-link" data-scroll-target="#step-6-set-thresholds-if-discrete-classes-are-needed">Step 6 — Set thresholds (if discrete classes are needed)</a></li>
  <li><a href="#step-7-produce-maps-and-validate-iteratively" id="toc-step-7-produce-maps-and-validate-iteratively" class="nav-link" data-scroll-target="#step-7-produce-maps-and-validate-iteratively">Step 7 — Produce maps and validate (iteratively)</a></li>
  </ul></li>
  <li><a href="#two-complementary-mapping-approaches-used-in-step-5" id="toc-two-complementary-mapping-approaches-used-in-step-5" class="nav-link" data-scroll-target="#two-complementary-mapping-approaches-used-in-step-5">Two complementary mapping approaches (used in Step 5)</a></li>
  <li><a href="#known-challenges" id="toc-known-challenges" class="nav-link" data-scroll-target="#known-challenges">Known challenges</a></li>
  <li><a href="#where-to-go-next" id="toc-where-to-go-next" class="nav-link" data-scroll-target="#where-to-go-next">Where to go next</a></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">General workflow</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="goal-of-the-workflow" class="level2">
<h2 class="anchored" data-anchor-id="goal-of-the-workflow">Goal of the workflow</h2>
<p>This workflow provides a consistent way to map ecosystem condition across South Africa’s diverse biomes, while still allowing each biome to use indicators and remote-sensing metrics that are context dependent and make ecological sense for that system. It is designed to support ecosystem risk assessment (e.g., Red List of Ecosystems criteria focused on degradation and biotic disruption), ecosystem accounting (e.g., repeated measures relative to a reference condition), as well as protected area and restoration prioritisation (end-user maps).</p>
</section>
<section id="the-general-workflow" class="level2">
<h2 class="anchored" data-anchor-id="the-general-workflow">The general workflow</h2>
<section id="step-1-define-assessment-units-and-identify-relevant-experts" class="level3">
<h3 class="anchored" data-anchor-id="step-1-define-assessment-units-and-identify-relevant-experts">Step 1 — Define assessment units and identify relevant experts</h3>
<p>Choose ecologically meaningful units (e.g., ecosystem types or functional groups) and involve experts who can co-define reference condition, key pressures, and interpret indicators.</p>
<p>Effective condition assessments require maps of the ecosystem extent to select units of assessments. Defining these units <em>a priori</em> is critical because they serve two purposes in the assessment: (1) they provide a consistent framework to delineate and describe the area of interest, and (2) they form the basis for interpreting ecological metrics in a meaningful way. The defined units should not span functionally dissimilar ecosystems, as it can obscure degradation patterns. In South Africa, the National Vegetation Map (NVM) is used as the primary terrestrial ecosystem typology and map, which classified South Africa’s diverse vegetation hierarchically into vegetation types nested within vegetation units, bioregions and nine biomes (Mucina and Rutherford, 2006). The NVM is iteratively updated and refined (Dayaram et al., 2019), and serves as a representation of the potential extent of vegetation types (pre-1750), providing a foundation for understanding the form and function of South African landscapes and its ecological processes, and a baseline for detecting ecological change (Dayaram et al., 2019). The vegetation types in the NVM (Mucina &amp; Rutherford, 2006; Dayaram et al.&nbsp;in prep) are used interchangeably as ecosystem types, since vegetation types were classified not only based on floristics but also abiotic conditions, such as geology, soil type and climate. These ecosystem types can intuitively be cross-referenced to the GET ecosystem types (Keith et al., 2020) with ecosystems being nested within broader-level biomes that correspond to specific geographic space. For countries without a national ecosystem classification system, the GET provides an ideal starting point as the typology for this workflow (see e.g.&nbsp;Wells et al., 2025), although the accompanying map, the Global Ecosystem Atlas, is not available for all countries yet.</p>
</section>
<section id="step-2-identify-key-pressures-and-change-pathways" class="level3">
<h3 class="anchored" data-anchor-id="step-2-identify-key-pressures-and-change-pathways">Step 2 — Identify key pressures and change pathways</h3>
<p>Screen threats and agree on the main pressures that plausibly drive degradation in the unit (e.g., unsustainable herbivory, bush encroachment, invasive plants, altered fire regimes, erosion). This step should produce a shared conceptual model of “what changes when the ecosystem degrades?”.</p>
</section>
<section id="step-3-define-a-reference-condition" class="level3">
<h3 class="anchored" data-anchor-id="step-3-define-a-reference-condition">Step 3 — Define a reference condition</h3>
<p>Define what “intact” (or benchmark) condition means for the unit, ideally across natural variability (seasonality, disturbance/recovery cycles, rainfall gradients). Reference sites should be documented and defensible.</p>
</section>
<section id="step-4-select-ecosystem-specific-indicators-of-condition" class="level3">
<h3 class="anchored" data-anchor-id="step-4-select-ecosystem-specific-indicators-of-condition">Step 4 — Select ecosystem-specific indicators of condition</h3>
<p>Translate ecological understanding into measurable indicators (structure/function and—where feasible—composition). Indicators should be linked to the pressures in Step 2 and be interpretable to end users.</p>
</section>
<section id="step-5-choose-remote-sensing-metrics-and-data-sources" class="level3">
<h3 class="anchored" data-anchor-id="step-5-choose-remote-sensing-metrics-and-data-sources">Step 5 — Choose remote-sensing metrics and data sources</h3>
<p>Select satellite/sensor data and metrics that are capable of detecting the chosen indicators at appropriate spatial and temporal scales. Time-series and phenology-based measures are often essential in seasonal systems.</p>
</section>
<section id="step-6-set-thresholds-if-discrete-classes-are-needed" class="level3">
<h3 class="anchored" data-anchor-id="step-6-set-thresholds-if-discrete-classes-are-needed">Step 6 — Set thresholds (if discrete classes are needed)</h3>
<p>Even if condition is mapped continuously, many applications require severity classes (e.g., intact / moderate / severe). Thresholds should be guided by the metric distributions, expert definitions, and (where available) state-and-transition understanding.</p>
</section>
<section id="step-7-produce-maps-and-validate-iteratively" class="level3">
<h3 class="anchored" data-anchor-id="step-7-produce-maps-and-validate-iteratively">Step 7 — Produce maps and validate (iteratively)</h3>
<p>Generate spatial outputs, validate against field/expert evidence, quantify uncertainty, and iterate with expert review until the product is ecologically defensible. Outputs can be continuous (0–1) or categorical depending on the use case.</p>
<hr>
</section>
</section>
<section id="two-complementary-mapping-approaches-used-in-step-5" class="level2">
<h2 class="anchored" data-anchor-id="two-complementary-mapping-approaches-used-in-step-5">Two complementary mapping approaches (used in Step 5)</h2>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A) Deviation-from-reference (reference-based)
</div>
</div>
<div class="callout-body-container callout-body">
<p>A simple, interpretable approach: measure how far each pixel deviates from the spectral/phenological signature of intact reference sites, then scale to a condition index.</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
B) Spatial modelling (predictive)
</div>
</div>
<div class="callout-body-container callout-body">
<p>Use expert/field-labelled training data and predictor layers (RS metrics + environment) to model and predict condition across space (e.g., using Random Forests). This is powerful in heterogeneous landscapes but needs careful validation and uncertainty reporting.</p>
</div>
</div>
<p>Both approaches can be appropriate; we generally choose based on data availability, the ecosystem, pressure signals, training data availability, and interpretability requirements.</p>
<hr>
</section>
<section id="known-challenges" class="level2">
<h2 class="anchored" data-anchor-id="known-challenges">Known challenges</h2>
<ul>
<li><strong>Natural variability vs degradation</strong>: seasonal cycles, rainfall variability, fire recovery and disturbance history can mimic degradation signals. We prefer time-series and phenology metrics and interpret everything relative to reference expectations.</li>
<li><strong>Unit definition matters</strong>: if the ecosystem unit is mapped too broadly, condition signals get blurred. We document the chosen units and revise if experts disagree.</li>
<li><strong>Remote sensing is proxy-based</strong>: we lean heavily on expert interpretation and transparent assumptions, and we treat uncertainty as a first-class output.</li>
</ul>
<hr>
</section>
<section id="where-to-go-next" class="level2">
<h2 class="anchored" data-anchor-id="where-to-go-next">Where to go next</h2>
<ul>
<li>If you want the general concept: read the <strong>Overview</strong> page.</li>
<li>If you want implementation detail: start with <strong>Thicket</strong> (completed example) and then <strong>Grassland</strong> (in progress).</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/vdmStephni\.github\.io\/ecosystem_condition\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>
  document.addEventListener("DOMContentLoaded", () => {
      document.querySelectorAll("figcaption").forEach(e => {
          const text = e.innerHTML.trim();
          // Only proceed if it starts with "Figure" or "Table"
          if (/^(Figure|Table)\b/.test(text)) {
            const match = text.match(/^([^<]*?\.)\s*(.*)$/s); // Match up to first period before any tag
          if (match) {
            const strongPart = `<strong>${match[1]}</strong>`;
            const rest = match[2];
            e.innerHTML = `${strongPart} ${rest}`;
          }
        }
      });
  });
</script>




</body></html>